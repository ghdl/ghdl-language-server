{
	// TODO: add examples to anything that isn't obvious
	// TODO: configuration (might be too annoying)
	// ? alphabetize
	// TODO: package generic vhdl 2008
	// TODO: open VSC enhancement to allow for user selections ($x) within or (${1||}) selection
	// TODO: open VSC bug about or selection for doing nothing still requires the editor insert a space or character
	// TODO: add notes/examples to descriptions
	// TODO: figure out how to column align with snippets such that when new lines are made for things like when/else
	//       or with select, cursor for next line is aligned with <=

	"Library": {
		"prefix": "library",
		"body": [
			"library ${1:ieee};",
			"$0"
		],
		"description": "library declaration"
	},
	"Library TextIO": {
		"prefix": "library_textio",
		"body": [
			"library std;",
			"use std.textio.all;",
			"$0"
		],
		"description": "TextIO library declaration"
	},
	"IEEE Libraries": {
		"prefix": "library_ieee",
		"body": [
			"library ieee;",
			"use ieee.std_logic_1164.all;",
			"use ieee.numeric_std.all;",
			"use ieee.math_real.all;",
			"$0"
		],
		"description": "common IEEE libraries declaration"
	},
	"IEEE Libraries 2008": {
		"prefix": "library_ieee_2008",
		"body": [
			"library ieee;",
			"context ieee.ieee_std_context;",
			"use ieee.math_real.all;",
			"$0"
		],
		"description": "common IEEE libraries declaration with 2008 standard context (vhdl 2008)"
	},
	"Use": {
		"prefix": "use",
		"body": [
			"use ${1:lib.pkg}.all;",
			"$0"
		],
		"description": "use clause"
	},
	// TODO: move this up into library_ieee inst and give user option to include any of these
	"Use IEEE Package": {
		"prefix": "use_ieee",
		"body": [
			"use ieee.${1|std_logic_1164,std_logic_textio,numeric_std,math_real,math_complex|}.all;",
			"$0"
		],
		"description": "use clause IEEE standard package (std_logic_1164,std_logic_textio,numeric_std,math_real,math_complex)"
	},
	"Context 2008": {
		"prefix": "context_2008",
		"body": [
			"context ${1:lib.context_name};",
			"$0"
		],
		"description": "context clause (vhdl 2008)"
	},
	"Context IEEE 2008": {
		"prefix": "context_ieee_2008",
		"body": [
			"context ieee.${1|ieee_bit_context,ieee_std_context|};",
			"$0"
		],
		"description": "context clause for IEEE standard contexts (ieee_bit_context,ieee_std_context) (vhdl 2008)"
	},
	// FIXME: this needs to allow second option with space/;
	"Others": {
		"prefix": ["others"],
		"body": [ "(others => ${1:<value>})${2| ,;|}$0" ],
		"description": "others keyword"
	},
	"When": {
		"prefix": "when",
		"body": [
			"when ${1:others} =>",
			"\t$0"
		],
		"description": "when statement"
	},
	"When Else": {
		"prefix": "when_else",
		"body": [
			"${1:signal} <= ${2:first_value} when ${3:expression}",
			"\telse ${4:final_value};",
			"$0"
		],
		"description": "concurrent when else statement"
	},
	"With Select": {
		"prefix": ["select", "with_select"],
		"body": [
			"with ${1:select} select",
			"\t${2:signal} <= ${3:first_value} when ${4:select_value},",
			"\t\t${5:last_value} when others;",
			"$0"
		],
		"description": "concurrent with select statement"
	},
	"Alias": {
		"prefix": "alias",
		"body": [
			"alias ${1:alias_name} : ${2:alias_type} is ${3:object_name};",
			"$0"
		],
		"description": "alias declaration"
	},
	// ? are signal/variable/constant all valid for external names
	"Alias External Name 2008": {
		"prefix": "alias_external_name_2008",
		"body": [
			"alias ${1:name} is",
			"\t<< ${2|signal,variable,constant|} ${3:path.to.signal.name} : ${4:type} >>;",
			"$0"
		],
		"description": "hierarchical signal declaration (vhdl 2008). NOTE: for standard types (SLV, unsighed, signed, etc.), no range needs to be specified"
	},
	"Array Type": {
		"prefix": "array",
		"body": [
			"type ${1:type_name} is array (${2:natural range<>}) of ${3:element_type};",
			"$0"
		],
		"description": "synthesizable attributes (high,low,left,right,range,reverse_range,length,event)"
	},
	"Assert Statement": {
		"prefix": "assert",
		"body": [
			"assert ${1:expression}",
			"\treport \"${2:string}\"",
			"\tseverity ${3|note,warning,error,failure|};",
			"$0"
		 ],
		"description": "assert statement"
	},
	"Constant": {
		"prefix": "constant",
		"body": [
			"constant ${1:name} : ${2:type} := ${3:default_value};",
			"$0"
		],
		"description": "constant declaration"
	},
	"File": {
		"prefix": "file",
		"body": [
			"file ${1:name} : text is ${2|in,out|} \"${3:file_name}\";",
			"$0"
		],
		"description": "constant declaration"
	},
	"Signal": {
		"prefix": "signal",
		"body": [
			"signal ${1:name} : ${2:type} := ${3:default_value};",
			"$0"
		],
		"description": "signal declaration"
	},
	"Variable": {
		"prefix": "variable",
		"body": [
			"variable ${1:name} : ${2:type} := ${3:default_value};",
			"$0"
		],
		"description": "variable declaration"
	},
	"Record Type": {
		"prefix": "record",
		"body": [
			"type ${1:name} is record",
			"\t${2:signal_name} : ${3:type};",
			"\t$0",
			"end record;"
		],
		"description": "record declaration"
	},


	"Component": {
		"prefix":"component",
		"body": [
			"component ${1:comp_name} is",
			"\tgeneric (",
			"\t\t${2:generics}",
			"\t);",
			"\tport (",
			"\t\t${3:clk   : in std_logic;}",
			"\t\t${4:reset : in std_logic;}",
			"\t\t$0",
			"\t);",
			"end component;"
		],
		"description": "component declaration"
	},
	"Entity": {
	"prefix": "entity",
		"body": [
			"entity ${1:$TM_FILENAME_BASE} is",
			"\tgeneric (",
			"\t\t${2:generics}",
			"\t);",
			"\tport (",
			"\t\t${3:clk   : in std_logic;}",
			"\t\t${4:reset : in std_logic;}",
			"\t\t$0",
			"\t);",
			"end entity;"
		],
		"description": "entity declaration"
	},
	"Architecture": {
		"prefix": "architecture",
		"body": [
			"architecture ${1:behav} of ${2:$TM_FILENAME_BASE} is",
			"\t$0",
			"begin",
			"end architecture;"
		],
		"description": "architecture declaration"
	},
	"Block": {
		"prefix": "block",
		"body": [
			"blk_${1:blockName} : block ${2| ,optional_guard_expression|}",
			"begin",
			"\t$0",
			"end block;"
		],
		"description": "block instantiation"
	},


	"If": {
		"prefix": "if",
		"body": [
			"if ${1:expression} then",
			"\t$0",
			"end if;"
		],
		"description": "if block"
	},
	"Elsif": {
		"prefix": "elsif",
		"body": [
			"elsif ${1:expression} then",
			"\t$0"
		],
		"description": "elsif block"
	},
	"Else": {
		"prefix": "else",
		"body": [
			"else",
			"\t$0"
		],
		"description": "else block"
	},
	"If Generate": {
		"prefix": "generate_if",
		"body": [
			"gen_${1:generateName} : if ${2:expression} generate",
			"\t$0",
			"end generate;"
		],
		"description": "if generate instantiation"
	},
	"Elsif Generate 2008": {
		"prefix": "generate_elsif_2008",
		"body": [
			"elsif ${1:expression} generate",
			"\t$0"
		],
		"description": "elsif generate instantiation (vhdl 2008)"
	},
	"Else Generate 2008": {
		"prefix": "generate_else_2008",
		"body": [
			"\telse generate",
			"\t\t$0"
		],
		"description": "else generate instantiation (vhdl 2008)"
	},
	"For": {
		"prefix": "for",
		"body": [
			"for ${1:i} in ${2:range} loop",
			"\t$0",
			"end loop;"
		],
		"description": "for loop block"
	},
	"For Generate": {
		"prefix": "generate_for",
		"body": [
			"gen_loop_${1:generateName} : for ${2:i} in ${3:range} generate",
			"\t$0",
			"end generate;"
		],
		"description": "for generate loop instantiation (vhdl 2008)"
	},
	"While": {
		"prefix": "while",
		"body": [
			"while ${1:expression} loop",
			"\t$0",
			"end loop;"
		],
		"description": "while loop block"
	},
	"Case": {
		"prefix": "case",
		"body": [
			"case ${1:select} is",
			"\twhen ${2:others} =>",
			"\t\t${3:null;}",
			"\t$0",
			"end case;"
		],
		"description": "case block"
	},
	"Case Generate 2008": {
		"prefix": "generate_case_2008",
		"body": [
			"gen_${1:generateName} : case ${1:select} generate",
			"\twhen ${2:others} =>",
			"\t\t${3:null;}",
			"\t$0",
			"end generate;"
		],
		"description": "case generate instantiation (vhdl 2008)"
	},
	"Process Combinatorial": {
		"prefix": "process_combinatorial",
		"body": [
			"process (${1:sensitivity_list})",
			"begin",
			"\t$0",
			"end process;"
		],
		"description": "combinatorial process block"
	},
	"Process Combinatorial 2008": {
		"prefix": "process_combinatorial_2008",
		"body": [
			"process (all)",
			"begin",
			"\t$0",
			"end process;"
		],
		"description": "combinatorial process block (vhdl 2008)"
	},
	"Process Asynchronous": {
		"prefix": "process_asynchronous",
		"body": [
			"process (${1:clk}, ${2:reset})",
			"begin",
			"\tif $2 = ${3|'1','0'|} then",
			"\t\t$4",
			"\telsif rising_edge($1) then",
			"\t\t$0",
			"\tend if;",
			"end process;"
		],
		"description": "asynchronous process block"
	},
	"Process Clocked": {
		"prefix": ["process_clocked"],
		"body": [
			"process (${1:clk})",
			"begin",
			"\tif rising_edge($1) then",
			"\t\tif ${2:reset} = ${3|'1','0'|} then",
			"\t\t\t$4",
			"\t\telse",
			"\t\t\t$0",
			"\t\tend if;",
			"\tend if;",
			"end process;"
		],
		"description": "clocked process block"
	},
	"Function": {
		"prefix": "function",
		"body": [
			"function ${1:name} (${2:params}) return ${3:type} is",
			"begin",
			"\t$0",
			"end function;"
		],
		"description": "function body declaration"
	},
	"Procedure": {
		"prefix": "procedure",
		"body": [
			"procedure ${1:name} (${2:params}) is",
			"begin",
			"\t$0",
			"end procedure;"
		],
		"description": "procedure body declaration"
	},
	"Package": {
		"prefix": "package",
		"body": [
			"package ${1:$TM_FILENAME_BASE} is",
			"\t$0",
			"end package;"
		],
		"description": "package declaration"
	},
	"Package Body": {
		"prefix": "package_body",
		"body": [
			"package body ${1:$TM_FILENAME_BASE} is",
			"\t$0",
			"end package;"
		],
		"description": "package body declaration"
	},
	"Natural Range": {
		"prefix": "natural_range",
		"body": [ "natural range<>" ],
		"description": "natural range statement"
	},


	"Standard Logic": {
		"prefix": ["std_logic", "sl"],
		"body": [ "std_logic${1| := ,;|}$0" ],
		"description": "type: std_logic"
	},
	"Standard Logic Type": {
		"prefix": ["std_logic", "sl"],
		"body": [ "std_logic${1| := ,;|}$0" ],
		"description": "type: std_logic"
	},
	"Standard ULogic": {
		"prefix": ["std_ulogic", "sul"],
		"body": [ "std_ulogic${1| := ,;|}$0" ],
		"description": "type: std_ulogic"
	},
	"Standard Logic Vector": {
		"prefix": ["std_logic_vector", "slv"],
		"body": [ "std_logic_vector($1 ${2|downto,to|} $3)${4| := ,;|}$0" ],
		"description": "type: std_logic_vector"
	},
	"Standard ULogic Vector": {
		"prefix": ["std_ulogic_vector", "sulv"],
		"body": [ "std_ulogic_vector($1 ${2|downto,to|} $3)${4| := ,;|}$0" ],
		"description": "type: std_ulogic_vector"
	},
	"Signed": {
		"prefix": "signed",
		"body": [ "signed($1 ${2|downto,to|} $3)${4| := ,;|}$0" ],
		"description": "type: signed"
	},
	"Unsigned": {
		"prefix": "unsigned",
		"body": [ "unsigned(${1} ${2|downto,to|} ${3})${4| := ,;|}$0" ],
		"description": "type: unsigned"
	}
}
